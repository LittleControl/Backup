# Node中模块的加载规则

## 一个共同的原则

就是模块优先从缓存中加载,也就是说一个系统中,一个模块只加载一次,就是最初引用的那一次  
举个例子,a文件中引用了b模块和c模块,b模块中引用了c模块,那么a中的对于c模块的引用,  
就会直接从缓存中加载,而不再从文件路径中读取,提升了性能  
代码示例

```JavaScript
//a.js
require('./b')
require('./c')
console.log('a 中的模块加载完成')
//b.js
console.log('b中模块被加载了')
require('./c')
//c.js
console.log('c中的模块被加载了')
//执行a.js的结果
Info: Start process (7:29:58 AM)
b中模块被加载了
c中的模块被加载了
a 中的模块加载完成
Info: End process (7:29:58 AM)
可以看到,c模块中的输出语句执行了一次
```

## 核心模块

这个我就不用多说了,系统默认自带的,直接`require('模块名')`就可以了

## 用户自定义模块

这个要注意的是模块的引入问题  
`require`的时候的关于模块路径有两种选择

1. 相对路径名,且不可以省略`./`或者`../`
2. 绝对路径名

## 第三方模块(npm安装的模块等)

这个引入模块的时候与核心模块类似,直接`require('模块名')`就可以了
我来解释一下其中引入的细节问题
当`require`一个第三方模块时,(注意第三方模块是不可能与核心模块重名的,这辈子都不可能的啦)
具体步骤如下:

1. 先在当前目录寻找`node_modules`文件夹
2. 在`node_modules`文件夹里找到模块名对应的目录
3. 再从模块名对应的目录中找到`package.json`文件
4. 从`package.json`中找到`main`对应的内容
5. 加载`main`中对应的文件
6. 如果`package.json`文件丢失或者`main`属性丢失或内容为空,则默认加载模块对应目录下的`index.js`文件
7. 如果当前目录不存在`node_modules`文件夹,则返回上一级目录开始寻找,重复以上或者
8. 直到根目录没有找到`node_modules`文件夹或者未找到模块对应的目录,则报错