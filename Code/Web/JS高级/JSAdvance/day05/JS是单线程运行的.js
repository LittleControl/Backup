/* 
    浏览器内核的线程模块分类
        主线程
            JS引擎模块(JS代码编译和运行)
            html,css文档解析模块:负责页面文本的解析
            DOM/CSS模块 负责dom/css在内存中的相关处理
            布局和渲染模块:负责页面的布局和效果的绘制(内存中的对象)
            ...
        分线程
            定时器模块: 负责定时器的管理
            事件响应模块: 负责事件的管理
            网络请求模块: 负责Ajax的请求
*/

/* 定时器引发的思考
    定时器不一定准时
*/
/* let t = Date.now()
console.log('start...')
setTimeout(function () {
    console.log(Date.now() - t)
    //当在定时器之后加入类似下面的for循环的时候,这时候定时器差的就有点多了
}, 200)
console.log('Nothing')
for ( var i = 0; i < 1000000000; i++) {

} */
/* 为什么JS要用单线程模式而不采用多线程 
     JS的单线程与她的用途有关
     JS主要是用于用户交互,操纵DOM元素
     如果不采用单线程就会带来很复杂的同步问题

*/
/* 
    一个概念,对于JS引擎而言,代码只有两种之分,初始化代码和回调代码
    一般而言,初始化代码就是可以理解为立即执行的代码,而回调代码则是类似于回调函数一样不会立即执行的代码

    JS引擎执行JS代码的基本流程
        - 执行初始化代码,包含一些特殊的代码
            - 设置定时器
            - 绑定事件监听
            - 发送Ajax请求
        - 在后面的某个时刻才会执行回调代码

    JS引擎的代码执行机制决定了JS代码的执行过程,也就意味了,及时想类似与setTimeout中的回调函数的延迟执行时间为0时也不会立即执行
    而是先吧初始化代码执行完毕以后才会再执行回调代码

*/
let a = 3
let b = 4
setTimeout(function(){
    console.log(0000)
},0)
setTimeout(function () {
    console.log(1111)
},1000)
console.log('Nothing To Do !!!')


/* 关于alert函数的一些注意点
    alert会中断主线程的执行以及定时器的计时
    只有用户按下确定按钮之后才会恢复
*/
